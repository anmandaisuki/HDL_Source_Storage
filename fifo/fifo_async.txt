クロックドメインが異なるため、fifoアドレスのインクリメントの部分だけグレイコードにしてフリップフロップ多段接続を使って、メタステーブルを除去できるようにしてる。
クロックエッジの瞬間にデータが変化するとメタステーブル（発振）になる。

（グレイコードを使えば16bitアドレスだろうが32bitアドレスだろうが、インクリメントでは1bitしか変化しない。32bitデータで32bitそれぞれが若干ずれたタイミングで変化する可能性があるデータと１つのクロックで１つのビットしか変化しないデータでは
１つのビットしか変化しないデータの方が対応しやすい。実際にフリップフロップを２段接続することで、２クロック分のデータの遅れが生じるがメタステーブルを防ぐことができる。）

クロックが高速で１クロックサイクルの間にメタステーブルが安定しない場合は、フリップフロップを多段にすることで対応できる。（その分更に、データのタイミングが遅くなる。）
フリップフロップを介すことで、データがフリップフロップを入れたサイクルだけ遅れる。データ転送レートは変わらない。

２ビット以上変化する場合、メターステーブルがどうこうというよりも、そのデータが正しいかわからない。５ビット目と６ビット目の変化のタイミングがズレていて、５ビット目が変化したタイミングでサンプリングが行われて、その後６ビット目が変化した場合など。
read側とwrite側で周波数の差が大きいと、アドレスの変化が周波数が遅い方は、早い方のクロックに追従できないので、full/emptyフラグのレスポンスが悪くなって、データ損失が起きるかも。

意外とシンプルでfullとemptyの出力以外はread側とwrite側で独立しているため、full,emptyフラグの生成以外でグレイコードは関わらない。
2段のフリップフロップでメタステーブルを取り除くときは、read側のデータはwrite側のクロックのフリップフロップ２段を通り、write側はread側のクロックのフリップフロップを通る。


ちょっと分かりにくいとこ

メタステーブルを避けるために、readアドレスをwriteアドレスと比較するときはwriteアドレスは2クロック前（read側のクロックのフリップフロップ２段を介した）のwriteアドレスを使う。
assign empty = (r_addr == w_addr2);  
assign full = (w_addr[ADDR_WIDTH]!=r_addr2[ADDR_WIDTH]) && (w_addr[ADDR_WIDTH-1:0]==r_addr2[ADDR_WIDTH-1:0]);

実際のアドレスは[ADDR_WIDTH-1:0]となっている。
リングバッファ構造を持っている。
↑
この条件のときに、最上位ビットが異なって、その他のビットが同じときというのはちょうど１周分の差があるということ。
つまり、writeアドレスとreadアドレスが１周分の差があり、fullということになる。

1111と0111は111の差がある。
011101と111101は11111の差がある。
２つの5bitの２進数が存在し5bit目だけ異なり残りの4bitが同じとき、その差は2^4の差がある。(2'b1111)
２つの10bitの２進数が存在し10bit目だけ異なり残りの9bitが同じとき、その差は2^9の差がある。(2'b111111111)